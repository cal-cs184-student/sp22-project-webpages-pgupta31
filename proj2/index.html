<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <style>
    body {
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
    }

    h1,
    h2,
    h3,
    h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
  </style>
  <title>CS 184 Mesh Editor</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

  <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2022</h1>
  <h1 align="middle">Project 2: Mesh Editor</h1>
  <h2 align="middle">Parth Gupta, cal-cs184-student/p2-meshedit-sp22-pgupta</h2>

  <br><br>

  <div>

    <h2 align="middle">Overview</h2>
    <p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole.
      Share your thoughts on what interesting things you've learned from completing the project.</p>

    <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

    <h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

    <p> De Casteljau's algorithm is a method we use to create smooth Bezier curves from a given set of control points. One important parameter for the algorithm is t, which ranges from 0 to 1 and will be used to control the weight for our linear interpolation function on each recursive step. Given the initial control points, the algorithm recursively creates a new set of points (one less than the original) found by linearly interpolating neighboring points based on the parameter t. In this task, we specifically implemented one step (moving from one set of points to another), allowing us to eventually reach a specific point that will be part of the Bezier curve at parameter t. Mathetmatically, at each step, we take a vector of points p0 through pk and construct k new intermediate points where p_i' is found from (1-t) * p_i + t * p_(i+1). By doing this, our code for the <code> BezierCurve::evaluateStep </code> function performs this step, returning a new vector containing the next set of intermediate points. </p>

	<p> See below for screenshots of the custom Bezier curve: </p>

	<p> See below for screenshots of the slightly modified custom Bezier curve: </p>

    <h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>

    <p> De Casteljau's algorithm extends to Bezier surfaces pretty nicely! Instead of using a list of 2D points, we now use a matrix of points in 3D space. This gives us a whole grid of control points, rather than just a list of control points, as we used in task 1. The algorithm first considers each row of control points individually, finding the point defined at u along the Bezier curve defined by each row's control points. The algorithm then proceeds with finding the Bezier curve along these points, now parametrized by a different parameter v. This finally gives us a unique point characterized by (u,v) along the Bezier surface originally defined by the grid of control points. </p>

	<p> In order to evaluate Bezier surfaces, I first did a 1D evaluation along one axis of the grid, for every row of points along this axis. This was done with respect to the u parameter. When put together, this gave us a vector of 3D vectors (list of 3D points) upon which we could do a 1D Bezier evaluation to give us the final Bezier curve (with respect to parameter v). At each iteration, we employed the use of the <code> BezierPatch::evaluate1D </code> function, which performed the same linear interpretation procedure as described in task 1 above. </p>

    <h2 align="middle">Section II: Sampling</h2>

    <h3 align="middle">Part 3: Average normals for half-edge meshes</h3>

    <p> In order to implement area-weighted vertex normals, I relied on the cross product. Essentially, when you take the cross product of two of the edges of a triangle, you get the unit normal vector scaled by the area of the triangle (an area-weighted normal vector!). My algorithm started with the halfedge currently stored by the vertex. I found the edge vectors (for the cross product) by computing the difference between each of the vertices of a given face (i.e. edge1 = v3 - v2 and edge2 = v2 - v1). I then added the cross product of these edges to an ongoing summed normal vector. In order to get from one face to its neighboring face (which also shares the vertex we started with), I went to the next halfedge of the current halfedge's twin (gets us in the same relative position of the neighboring triangle). Then, I proceeded this iteration until we visited all neighboring triangles (once we returned to the starting half-edge). Finally, I normalized the ongoing summed normal vector to get the final result. </p>

    <p> See below for screenshots of the different teapot shading: </p>

    <h3 align="middle">Part 4: Half-edge flip</h3>

    <p> In order to implement the edge flip operation, I first manually saved pointers to all the initial halfedges, faces, and vertices. This made it easier to redirect pointers when doing the pointer manipulation later on. I think went through each half-edge, vertex, and face, updating the corresponding fields for each. For half-edges, the primary things to pay close attention to were changing next pointers, changing starting vertices, and changing faces. For all the vertices and faces, I made sure to update their corresponding halfedges because we don't know what those were initially set to (so just to be safe since we were moving the middle edge). </p>

    <p> I didn't really use any interesting debugging tricks, but the primary implementation trick I used (that saved lots of time) was just saving pointers to everything before manipulating anything. This made sure that I knew exactly what I was redirecting each pointer to, since manipulating as I went would have likely made the implementation much harder. </p>

    <p> In terms of my debugging journey, I just made sure the code visually made sense (when drawn on paper) and then tested the implementation on the teapot mesh. It luckily seemed to work well on the first shot so I improved the implementation (did less updates than necessary) and tested again! </p>

    <p> See below for screenshots of the teapot mesh before and after performing edge flips: </p>

    <h3 align="middle">Part 5: Half-edge split</h3>

    

    <h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>



    <h2 align="middle">Section III: Optional Extra Credit</h2>
    <p>If you are not participating in the optional mesh competition, don't worry about this section!</p>

    <h3 align="middle">Part 7: Design your own mesh!</h3>

    <p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a
      column in that row. You might find this useful for framing and showing your result images in an organized fashion.
    </p>

    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/image1.png" align="middle" width="400px" />
            <figcaption align="middle">Caption goes here.</figcaption>
          </td>
          <td>
            <img src="images/image2.png" align="middle" width="400px" />
            <figcaption align="middle">Caption goes here.</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/image3.png" align="middle" width="400px" />
            <figcaption align="middle">Caption goes here.</figcaption>
          </td>
          <td>
            <img src="images/image4.png" align="middle" width="400px" />
            <figcaption align="middle">Caption goes here.</figcaption>
          </td>
        </tr>
      </table>
    </div>

</body>

</html>